// ===== Basic config =====
const ORIGIN = location.origin;
let API_PREFIX = '/api';
(async () => {
  for (const p of ['/api', '']) {
    try {
      const r = await fetch(`${ORIGIN}${p}/healthz`);
      if (r.ok) { API_PREFIX = p; break; }
    } catch {}
  }
})();

// ===== UI =====
const startBtn = document.getElementById('start');
const stopBtn  = document.getElementById('stop');
const transcriptEl = document.getElementById('transcript');
const player = document.getElementById('player');

// ===== State machine =====
const State = Object.freeze({ IDLE:'idle', LISTENING:'listening', THINKING:'thinking', SPEAKING:'speaking' });
let state = State.IDLE;

// ===== Audio graph + VAD =====
let ctx, analyser, stream, source, rafId;
let recorder, chunks = [], recording=false;
let vadSpeaking = false, vadSilenceSince = 0;
let noiseFloor = 0.01;
const VAD_HANGOVER_MS = 300;
const VAD_BASE = 0.02;

// ===== TTS control (hard barge-in) =====
let ttsAbort = null;
let ttsBlobURL = '';
let ttsPlaying = false;
player.addEventListener('playing', () => ttsPlaying = true);
player.addEventListener('ended',   () => ttsPlaying = false);
player.addEventListener('pause',   () => ttsPlaying = false);

function stopTTSLocal() {
  try { player.pause(); } catch {}
  ttsPlaying = false;
  if (ttsAbort && !ttsAbort.signal.aborted) try { ttsAbort.abort(); } catch {}
  ttsAbort = null;
  if (ttsBlobURL) { URL.revokeObjectURL(ttsBlobURL); ttsBlobURL = ''; }
}
async function stopTTSServer() {
  try { await fetch(`${ORIGIN}${API_PREFIX}/tts/stop`, { method:'POST' }); } catch {}
}
async function bargeIn() {
  // stop TTS immediately (network + audio + server)
  stopTTSLocal();
  stopTTSServer();
}

// ===== Mic start/stop =====
async function start() {
  stream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:true, noiseSuppression:true } });
  ctx = new (window.AudioContext||window.webkitAudioContext)();
  analyser = ctx.createAnalyser(); analyser.fftSize = 2048;
  source = ctx.createMediaStreamSource(stream); source.connect(analyser);
  state = State.LISTENING;
  draw();
  startBtn.disabled = true; stopBtn.disabled = false;
}
function stop() {
  cancelAnimationFrame(rafId);
  if (recorder && recorder.state !== 'inactive') recorder.stop();
  if (stream) stream.getTracks().forEach(t=>t.stop());
  if (ctx?.state !== 'closed') ctx?.close();
  state = State.IDLE;
  startBtn.disabled = false; stopBtn.disabled = true;
}

// ===== VAD loop =====
async function draw() {
  const data = new Uint8Array(analyser.fftSize);
  analyser.getByteTimeDomainData(data);
  let sum=0; for (let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
  const energy = Math.sqrt(sum/data.length);
  noiseFloor = 0.98*noiseFloor + 0.02*energy;
  const dynThresh = Math.max(VAD_BASE, noiseFloor*2.2);

  const now = performance.now();
  // While TTS plays, demand stronger sustained energy to barge-in (reduce echo false-positives)
  const requireFactor = ttsPlaying ? 2.2 : 1.0;
  const isSpeech = energy >= dynThresh * requireFactor;

  if (isSpeech) {
    if (!vadSpeaking) onSpeechStart();
    vadSpeaking = true; vadSilenceSince = 0;
  } else if (vadSpeaking) {
    if (!vadSilenceSince) vadSilenceSince = now;
    if (now - vadSilenceSince > VAD_HANGOVER_MS) {
      onSpeechEnd();
      vadSpeaking = false; vadSilenceSince = 0;
    }
  }
  rafId = requestAnimationFrame(draw);
}

async function onSpeechStart(){
  // HARD barge-in: kill any playing TTS ASAP
  await bargeIn();

  // Start recorder if needed
  if (!recording) {
    chunks = [];
    const mime = pickMime();
    try { recorder = new MediaRecorder(stream, { mimeType: mime }); }
    catch { recorder = new MediaRecorder(stream); }
    recorder.ondataavailable = e => { if (e.data?.size) chunks.push(e.data); };
    recorder.onstop = onUtteranceComplete;
    recorder.start(150); // ~150ms chunks
    recording = true;
    state = State.LISTENING;
  }
}

function onSpeechEnd(){
  if (recording && recorder && recorder.state !== 'inactive') {
    recorder.stop();
    recording = false;
  }
}

function pickMime(){
  const prefs = [
    'audio/webm;codecs=opus', 'audio/webm',
    'audio/ogg;codecs=opus',  'audio/ogg',
    'audio/mp4', 'audio/mpeg'
  ];
  for (const m of prefs) if (MediaRecorder.isTypeSupported?.(m)) return m;
  return '';
}

// ===== End of utterance → STT → intent → TTS =====
async function onUtteranceComplete() {
  try {
    const mime = recorder.mimeType || 'audio/webm';
    const blob = new Blob(chunks, { type: mime });
    chunks = [];
    if (!blob.size) return;

    // STT
    state = State.THINKING;
    const ext = (mime.split('/')[1] || 'webm').split(';')[0] || 'webm';
    const fd = new FormData(); fd.append('file', blob, `input.${ext}`);
    const tr = await fetch(`${ORIGIN}${API_PREFIX}/transcribe`, { method:'POST', body: fd });
    const ttext = await tr.text();
    if (!tr.ok) throw new Error(`STT ${tr.status} ${ttext}`);
    const { text } = JSON.parse(ttext);
    transcriptEl.textContent = text || '';
    if (!text?.trim()) { state = State.LISTENING; return; }

    // Intent → routing → text response
    const ir = await fetch(`${ORIGIN}${API_PREFIX}/determine_intent`, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ message: text })
    });
    const ibody = await ir.text();
    if (!ir.ok) throw new Error(`Intent ${ir.status} ${ibody}`);
    const intent = JSON.parse(ibody);
    const reply = (intent.result || '').trim();
    if (!reply) { state = State.LISTENING; return; }

    // TTS (abortable)
    await speak(reply);
  } catch (e) {
    console.error('Pipeline error:', e);
    state = State.LISTENING;
  }
}

async function speak(text, voice='alloy') {
  state = State.SPEAKING;
  stopTTSLocal();               // ensure clean start
  ttsAbort = new AbortController();
  try {
    // Make sure AudioContext is active (Chrome sometimes suspends it)
    try { if (ctx && ctx.state === 'suspended') await ctx.resume(); } catch {}
    const r = await fetch(`${ORIGIN}${API_PREFIX}/tts`, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ text, voice }),
      signal: ttsAbort.signal
    });
    if (!r.ok) {
      const b = await r.text(); throw new Error(`TTS ${r.status} ${b}`);
    }
    const buf = await r.arrayBuffer();
    const blob = new Blob([buf], { type:'audio/mpeg' });
    ttsBlobURL = URL.createObjectURL(blob);
    player.src = ttsBlobURL; player.load();
    try { await player.play(); } catch {}
    // When playback ends naturally, go back to listening
    player.onended = () => { state = State.LISTENING; };
  } catch (e) {
    if (e.name !== 'AbortError') console.error('TTS error:', e);
    state = State.LISTENING;
  }
}

// ===== UI =====
startBtn.onclick = start;
stopBtn.onclick  = stop;
