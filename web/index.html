<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Realtime Voice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{font-family:system-ui;margin:2rem;max-width:800px}
    button{padding:.6rem 1rem;margin-right:.5rem}
    pre{background:#f6f6f6;padding:1rem;border-radius:.5rem;white-space:pre-wrap}
    .status{font-size:.9rem;color:#666;margin:.5rem 0}
    .error{color:#b00020}
    .ok{color:#0a7b22}
  </style>
</head>
<body>
  <h1>Realtime Voice</h1>
  <p>Click Start to grant mic access. Speak any time‚ÄîTTS will stop instantly when you talk.</p>

  <button id="start">üéôÔ∏è Start</button>
  <button id="stop" disabled>‚èπÔ∏è Stop</button>
  <div class="status" id="status">Idle</div>

  <p><strong>Partial:</strong> <span id="partial"></span></p>
  <pre id="final"></pre>

  <script>
  const WS_PATH = '/ws/stream';
  const WS_URL  = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + WS_PATH;

  let ws, pingTimer, audioCtx, processor, src, stream, running=false, ttsPlayer=null;

  // --- Tiny PCM streamer (ScriptProcessorNode; fine for MVP) ---
  class PCMStreamer {
    constructor(targetRate=24000){
      this.ctx = new (window.AudioContext||window.webkitAudioContext)();
      this.deviceRate = this.ctx.sampleRate;      // ~48000
      this.targetRate = targetRate;
      this.q = [];
      this.node = this.ctx.createScriptProcessor(2048,1,1);
      this.node.onaudioprocess = e => this._pull(e);
      this.node.connect(this.ctx.destination);
    }
    stop(){ try{this.node.disconnect()}catch{}; try{this.ctx.close()}catch{}; this.q=[]; }
    pushB64PCM16(b64){
      const bin = atob(b64), buf = new ArrayBuffer(bin.length), u8 = new Uint8Array(buf);
      for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
      this.pushPCM16(new Int16Array(buf));
    }
    pushPCM16(int16){
      const f32 = new Float32Array(int16.length);
      for(let i=0;i<int16.length;i++) f32[i] = int16[i]/0x8000;
      this.q.push(resampleLinear(f32, this.targetRate, this.deviceRate));
    }
    _pull(e){
      const out = e.outputBuffer.getChannelData(0);
      let off=0;
      while(off<out.length && this.q.length){
        const frame=this.q[0], take=Math.min(out.length-off, frame.length);
        out.set(frame.subarray(0,take), off);
        off+=take;
        if(take<frame.length) this.q[0]=frame.subarray(take); else this.q.shift();
      }
      if(off<out.length) out.fill(0,off);
    }
  }
  function resampleLinear(f32,inR,outR){
    if(inR===outR) return f32;
    const ratio=outR/inR, out=new Float32Array(Math.floor(f32.length*ratio));
    let pos=0;
    for(let i=0;i<out.length;i++){
      const idx=pos|0, frac=pos-idx, a=f32[idx]||0, b=f32[idx+1]||0;
      out[i]=a+(b-a)*frac; pos+=1/ratio;
    }
    return out;
  }
  function toB64(u8){ let s=""; for(let i=0;i<u8.length;i++) s+=String.fromCharCode(u8[i]); return btoa(s); }
  function f32ToI16(f){ const o=new Int16Array(f.length); for(let i=0;i<f.length;i++){ let s=Math.max(-1,Math.min(1,f[i])); o[i]=s<0?s*0x8000:s*0x7FFF; } return o; }
  function downsample(buf,inRate,outRate=16000){
    if(inRate===outRate) return buf;
    const ratio=inRate/outRate, outLen=Math.floor(buf.length/ratio);
    const out=new Float32Array(outLen); let pos=0;
    for(let i=0;i<outLen;i++){ out[i]=buf[Math.floor(pos)]; pos+=ratio; }
    return out;
  }

  // --- Helpers ---
  const $ = (id)=>document.getElementById(id);
  function setStatus(text, ok=false, err=false){
    const el=$('status'); el.textContent=text; el.classList.toggle('ok',ok); el.classList.toggle('error',err);
  }

  function attachWSHandlers(socket){
    console.log("WS_URL =", WS_URL);
    socket.onopen = () => {
      console.log("[WS] open");
      setStatus("WebSocket connected ‚úî", true, false);
      // light keepalive
      pingTimer = setInterval(()=> {
        if (socket.readyState === WebSocket.OPEN) {
          try { socket.send(JSON.stringify({type:"ping", t:Date.now()})); } catch {}
        }
      }, 20000);
    };
    socket.onerror = (e) => {
      console.error("[WS] error", e);
      setStatus("WebSocket error", false, true);
    };
    socket.onclose = (e) => {
      console.warn("[WS] close", e.code, e.reason);
      setStatus(`WebSocket closed (${e.code})`, false, true);
      if (pingTimer) { clearInterval(pingTimer); pingTimer=null; }
    };
    socket.onmessage = (evt) => {
      const m = JSON.parse(evt.data);
      if(m.type==="partial"){ $('partial').textContent = m.text; }
      if(m.type==="final"){
        $('partial').textContent = "";
        $('final').textContent = `You: ${m.text}\nAssistant: ${m.reply}`;
      }
      // TTS streaming
      if(m.type==="tts_start"){
        if(ttsPlayer) ttsPlayer.stop();
        ttsPlayer = new PCMStreamer(m.sample_rate||24000);
        ttsPlayer.ctx.resume();
      }
      if(m.type==="tts_chunk" && ttsPlayer){
        ttsPlayer.pushB64PCM16(m.pcm_b64);
      }
      if(m.type==="tts_end"){
        setTimeout(()=>{ if(ttsPlayer){ ttsPlayer.stop(); ttsPlayer=null; }}, 300);
      }
      // INSTANT STOP cues
      if(m.type==="tts_stop" || (m.type==="event" && m.name==="speech_started")){
        if(ttsPlayer){ ttsPlayer.stop(); ttsPlayer=null; }
      }
    };
  }

  function waitForOpen(socket, timeoutMs=8000){
    return new Promise((resolve, reject)=>{
      if (socket.readyState === WebSocket.OPEN) return resolve();
      const onOpen = ()=>{ cleanup(); resolve(); };
      const onErr  = (e)=>{ cleanup(); reject(e); };
      const onClose= (e)=>{ cleanup(); reject(new Error(`closed ${e.code}`)); };
      const timer = setTimeout(()=>{ cleanup(); reject(new Error("ws open timeout")); }, timeoutMs);
      function cleanup(){
        clearTimeout(timer);
        socket.removeEventListener('open', onOpen);
        socket.removeEventListener('error', onErr);
        socket.removeEventListener('close', onClose);
      }
      socket.addEventListener('open', onOpen);
      socket.addEventListener('error', onErr);
      socket.addEventListener('close', onClose);
    });
  }

  async function start(){
    if(running) return; running=true;
    setStatus("Connecting WebSocket‚Ä¶");

    // 1) Connect WS first, fail fast if routing is broken
    ws = new WebSocket(WS_URL);
    attachWSHandlers(ws);
    try {
      await waitForOpen(ws, 12000);
    } catch (e) {
      console.error("WS failed to open:", e);
      setStatus("WebSocket failed to open. Check /ws routing.", false, true);
      running=false;
      return;
    }

    // 2) Ask for mic and start streaming frames
    try{
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (e) {
      console.error("getUserMedia error:", e);
      setStatus("Mic permission denied.", false, true);
      running=false;
      return;
    }

    audioCtx = new (window.AudioContext||window.webkitAudioContext)({ sampleRate:48000 });
    if (audioCtx.state === 'suspended') { try{ await audioCtx.resume(); }catch{} }

    const srcNode = audioCtx.createMediaStreamSource(stream);
    const proc = audioCtx.createScriptProcessor(1024,1,1); // ~21ms @48k
    srcNode.connect(proc); proc.connect(audioCtx.destination);
    processor = proc; src = srcNode;

    processor.onaudioprocess = (e)=>{
      if(!ws || ws.readyState!==WebSocket.OPEN) return;
      const input = e.inputBuffer.getChannelData(0);
      const ds = downsample(input, audioCtx.sampleRate, 16000);
      const i16 = f32ToI16(ds);
      try{
        ws.send(JSON.stringify({ type:"audio", audio_b64: toB64(new Uint8Array(i16.buffer)) }));
      }catch(err){
        // swallow transient send errors
      }
    };

    $('start').disabled = true;
    $('stop').disabled = false;
    setStatus("Streaming‚Ä¶ speak any time.", true, false);
  }

  function stop(){
    running=false;
    // tell server to kill any TTS immediately
    try{ if(ws && ws.readyState===WebSocket.OPEN) ws.send(JSON.stringify({ type:"barge_in" })); }catch{}
    try{ processor && processor.disconnect(); }catch{}
    try{ src && src.disconnect(); }catch{}
    try{ stream && stream.getTracks().forEach(t=>t.stop()); }catch{}
    try{ audioCtx && audioCtx.close(); }catch{}
    try{ pingTimer && clearInterval(pingTimer); pingTimer=null; }catch{}
    try{ ws && ws.close(); }catch{}
    if(ttsPlayer){ ttsPlayer.stop(); ttsPlayer=null; }
    $('start').disabled = false;
    $('stop').disabled = true;
    setStatus("Stopped.");
  }

  $('start').onclick = start;   // user gesture unlocks audio
  $('stop').onclick  = stop;

  // Close WS cleanly if user leaves
  window.addEventListener('beforeunload', ()=>{ try{ ws && ws.close(); }catch{} });
  </script>
</body>
</html>
